---
layout: post
title:  "JPA M:N(다대다) 설계와 구조"
date:   2022-01-17 21:20:00 +0900
categories: dev
---

# M:N 관계의 특징
다대다 관계는 논리적인 설계와 실제 테이블 설계가 다르다. 예를 들어, '영화' 엔티티와 '회원' 엔티티를 비교할때, 모두 독립적인 인티티로 설계가 가능하다. (대부분 명사인 경우가 많음) 회원의 입장에선 여러편의 영화를 평가하는 관계가 될 수도 있고, 반대로 영화의 입장에서는 한편을 보는데 여러 회원이 참여하는 관계로 될수 있다. 

**비슷한 다대다 관계 샘플**

- 학생과 수업의 관계
- 상품과 상품 카테고리
- 상품과 회원의 관계

여기서 문제가 하나 생긴다. 다대다 관계는 테이블로 설계를 할수 없다는 것이다. 관계형 데이터베이스 특성상 테이블이라는 정형화된 구조를 가지는 방법으로 만들어진다. 이때 칼럼을 지정하면서 최대 크기를 지정하기 때문에 수평적으로 확장은 불가능하다. 

반면에 테이블은 Row라는 개념을 이용해서 수직적으로 확장이 가능하다. 다대다 관계를 만들려면, 매핑테이블을 사용한다. 
예를 들면, 영화와 회원 사이를 잇는 리뷰 매핑 테이블과 같은 것을 의미한다. 

- 매핑 테이블의 작성 이전에 다른 테이블들이 먼저 존재해야함
- 매핑 테이블은 주로 '명사'가 아닌 '동사'나 히스토리'에 대한 데이터를 보관하는 용도
- 매핑 테이블은 중간에서 양쪽의 PK를 참조하는 형태

# JPA에서 M:N 처리
- @ManyToMany
- 별도의 엔티티를 설계하고, @ManyToOne을 이용해서 처리하는 방식 

특히 @ManyToMany를 이용할 때, 양방향 참조를 이용하는데, JPA의 실행에서 가장 중요한 것이 현재 컨텍스트의 엔티티 객체들의 상태와 데이터베이스의 상태를 동기화시키는 점이라고 생각해보면, 하나의 객체를 수정하는 경우에 다른 객체 상태를 매번 일치시키는 것은 쉽지 않다. 실무에서도 가능하면 단방향 참조를 위주로 프로젝트를 진행

매핑 테이블은 주로 '동사'나 '히스토리'를 위미하는 테이블 

ex) 회원이 영화에 대해서 평점을 줄때, 평점을 준다는 부분은 매핑 테이블(이부분이 @ManyToMany를 이용하는 방식과의 차이) 

![다대다 table ERD](/assets/img/10.png)

# N+1 문제
1번의 쿼리로 N개의 데이터를 가져왔는데, N개의 데이터를 처리하기 위해 추가적인 쿼리가 N개 수행되는 상황
성능에 문제가 생기므로 반드시 해결 필요

*수정 전 쿼리*
~~~ java

public interface MovieRepository extends JpaRepository<Movie, Long> {

    @Query("select m, max(mi), avg(coalesce(r.grade,0)), count(distinct  r) from Movie m" +
            " left outer join MovieImage mi on mi.movie = m " +
            " left outer join Review r on r.movie = m group by m")
    Page<Object []> getListPage(Pageable pageable);

}

~~~
아래 쿼리는 movie_image 테이블에서 해당하는 모든 영화의 이미지를 다 가져오는 쿼리.
목록을 가져오는 쿼리는 문제가 없지만, Max()를 이용하는 부분이 들어가면서 해당 영화의 모든 부분을 가져와 해당 영화의 모든 이미지를 가져오는 쿼리가 수행(N+1 문제)
~~~ SQL

 select
        movieimage0_.inum as inum1_2_0_,
        movieimage0_.img_name as img_name2_2_0_,
        movieimage0_.movie_mno as movie_mn5_2_0_,
        movieimage0_.path as path3_2_0_,
        movieimage0_.uuid as uuid4_2_0_ 
    from
        movie_image movieimage0_ 
    where
        movieimage0_.inum=?

~~~

**이 문제를 해결하기 위해선, 중간의 이미지를 한개로 줄여서 처리**
(max()를 빼고, MovieImage를 출력한다.)

# Mysql Group By 이슈
max() aggregation 함수를 제거 후에, 실행을 했는데, SQL_MODE에 대한 이슈가 계속 생겼다. Mysql 5.7버전에서 sql_mode가 생겼는데, only_full_group_by 때문에 Group by 절에서 명명되지 않았거나, 기능적으로 종속적이지 않은 집계되지 않은 열을 참조하는 경우 쿼리를 거부한다. 

이를 해결하기 위해선, 표준에 맞게 쿼리를 작성하거나, 아래 쿼리를 수행해서 속성을 끌수 있다. 

~~~

SET GLOBAL sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));
~~~

*수정 후 쿼리*

~~~java

    @Query("select m, mi, avg(coalesce(r.grade,0)), count(distinct  r) from Movie m" +
            " left outer join MovieImage mi on mi.movie = m " +
            " left outer join Review r on r.movie = m group by m")
    Page<Object []> getListPage(Pageable pageable);
~~~
